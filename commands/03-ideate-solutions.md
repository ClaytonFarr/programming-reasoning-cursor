Remember, our larger goal is to create a software product that will help our audience(s) make meaningful progress toward overcoming this problem within our expected contexts. To this end our immediate goal is to ideate a variety of possibly high-quality solutions.

# Ideate Possible Solutions

If the section "# Solution Ideas" does not exist create it.

If the section "## Initial Ideas" does not exist, create this heading within "# Solution Ideas" section.

Go through each ideation technique listed below in order (e.g. HYPOTHETICAL, SCAMPER, etc). For each ideation technique determine 3 high-quality possible solutions to our problem for our audience(s) and context(s) utilizing the perspective of this ideation technique.

For each possible solution:
1. *Determine possible solution*: take a moment to consider the solution's likely specific features, design, and/or technologies that help it solve the problem in a unique way from the perspective of this technique; ach solution should be unique in how it solves the problem from the approach of other solutions.
2. *Create Solution Summary*: write a summary of the solution details (features, design, technology) and how they specifically help solve the problem for the audience; the solution summary should be specific enough to clearly identify how it is unique from other solutions; be as detailed as necessary while still being as brief as possible (try to stay under 350 characters in length)
3. *Determine Solution Name*: a short and meaningful name that briefly and clearly distinguishes the solution
4. *Create Evaluation Summary*: evaluate the solution's likelihood to solve the problem effectively (including reasons why) and the likely technical complexity/scope required to to build and distribute a meaningful first version (including reasons why); rate the evaluated likelihood and complexity/scope as 'high', 'med', or 'low' (see details below for Technical Complexity/Scope Ratings); determine a solution score using the Scoring Rubric below and write a brief summary of your evaluation using the format: `Score: {score} - {high|medium|low} likelihood of solving problem ({reason(s)}), {high|medium|low} complexity ({reason(s)})`

TECHNICAL COMPLEXITY/SCOPE RATINGS:

- low = simple/web technologies | limited feature set | can be built by 1-2 engineers in < 1 month
- medium = moderate technology | moderate features set | could be built by 2-3 engineers in < 3 months
- high = advanced technology | expansive feature set | requires 5+ engineers to deliver < 6 months

SCORING RUBRIC:

| Likelihood | Complexity/Scope | Score |
| ---------- | ---------------- | ----- |
| High       | High             | 5     |
| High       | Medium           | 8     |
| High       | Low              | 10    |
| Med        | High             | 4     |
| Med        | Medium           | 7     |
| Med        | Low              | 8     |
| Low        | High             | 1     |
| Low        | Medium           | 3     |
| Low        | Low              | 6     |

Use the following format to write the possible solutions for each ideation technique -

```

*{TECHNIQUE-LABEL (e.g. HYPOTHETICAL)}*
- *{Solution Name}*: {Solution Summary} [{Evaluation Summary}]
- ...
```

If the section "## Initial Ideas" does exist, review the current solutions. If there are less than 3 solutions for any of the ideation techniques listed below, determine additional high-quality solutions using this technique to bring the total number to 3.

**Ideation Techniques**

- JTBD: What software solutions might be most effective from a "Jobs to be Done" perspective?
- SCAMPER: How might we adapt existing solution(s) to solve this problem? (Substitute, Combine, Adapt, Modify, Put to another use, Eliminate, Reverse)
- TRANSPLANT: How might we take inspiration from how similar problems are solved in other industries?
- SIX-HATS: How might different perspectives solve this problem using software?
- SIMPLE: If resources are highly-constrained, what'd be the simplest solution that still solves the problem?
- INVERSED: What assumptions are we making and what solution(s) might be possible if we reversed them?
- SPECIFIC-USER: What solution(s) might be best if it was focused on one specific user persona?
- TRENDS: What software solutions might be useful based on current trends?
- IN-OUT: If we consider the inputs and outputs of the entire system what solutions might be most effective?
- FEEDBACK: If we incorporate feedback mechanisms what solutions might be most adaptive and effective?
- STREAMLINE: Which solutions might be most effective at eliminating or minimizing existing friction points?
- INFALLIBLE: What solutions would we try if we couldn't not fail?
- BLANK-CHECK: What solutions might be most effective and possible if budget were not a concern?